# 9. 技术决策记录

### 9.1 为什么使用 ConcurrentHashMap 而非普通 HashMap?

**决策**: 使用 `ConcurrentHashMap` 作为内存存储的默认实现

**原因**:
1. **线程安全**: 多线程并发访问 Token 注册表
2. **性能**: 分段锁机制,读写性能优于 `Hashtable`
3. **无锁读取**: 读操作完全无锁,适合读多写少的场景

**权衡**:
- ✅ 优点: 高并发性能、线程安全
- ❌ 缺点: 内存占用稍高于普通 HashMap

### 9.2 为什么支持多种 Token 提取方式?

**决策**: 支持从 Header、Cookie、RequestParameter 提取 Token

**原因**:
1. **兼容性**: 支持不同客户端类型 (浏览器、移动 App、API 客户端)
2. **灵活性**: 根据场景选择最合适的传输方式
3. **渐进迁移**: 从 Cookie 迁移到 Bearer Token 时保持兼容

**优先级**:
1. **Header** (推荐): RESTful API 标准方式
2. **Cookie**: 浏览器 Web 应用
3. **Parameter**: 特殊场景 (如 WebSocket 握手、第三方回调)

### 9.3 为什么设计两种 Token 类型?

**决策**: 提供 `TimeoutAccessToken` 和 `HardTimeoutToken` 两种类型

**原因**:
1. **TimeoutAccessToken (自动续期)**
   - 用途: 用户会话管理
   - 特性: 保持活跃自动续期
   - 场景: Web 应用登录态

2. **HardTimeoutToken (固定时间)**
   - 用途: 临时令牌 (验证码、一次性链接)
   - 特性: 固定时间后失效
   - 场景: 邮箱验证、密码重置、临时分享链接

**设计模式**: 策略模式 (ExpirationPolicy)

### 9.4 为什么使用 Redis 而非数据库?

**决策**: 优先推荐 Redis 作为分布式存储

**原因**:
1. **性能**: Redis 内存存储,访问速度远超数据库
2. **TTL 支持**: 原生支持自动过期,无需定时清理任务
3. **分布式**: 天然支持集群和主从复制
4. **简单**: 无需设计表结构和索引

**权衡**:
- ✅ 优点: 高性能、自动过期、分布式友好
- ❌ 缺点: 额外的 Redis 依赖、内存成本

**扩展**: 系统提供扩展点,支持自定义数据库存储 (参见 [8.3 自定义 TokenRegistry](#83-自定义-tokenregistry))

### 9.5 为什么禁用部分 Spring Security 默认行为?

**决策**: 默认禁用 CSRF、Session 管理

**原因**:
1. **CSRF**: RESTful API 使用 Bearer Token,不依赖 Cookie,无需 CSRF 保护
2. **Session**: 基于 Token 的无状态认证,不需要 Session

**可配置**: 用户可通过继承 `TokenSecurityConfig` 自定义行为

### 9.6 为什么使用 `@AutoConfigureBefore`?

**决策**: 使用 `@AutoConfigureBefore` 控制自动配置顺序

**原因**:
1. **依赖关系**: `TokenConfig` 必须在 `TokenApiConfig` 之前,确保 Redis 注册表优先创建
2. **条件装配**: `@ConditionalOnMissingBean` 依赖加载顺序
3. **可预测**: 明确的加载顺序,避免随机失败

**顺序**:
```
TokenConfig → TokenApiConfig → TokenCoreAutoConfig
```

---
