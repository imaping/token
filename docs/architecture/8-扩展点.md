# 8. 扩展点

### 8.1 自定义 Token 类型

**步骤 1: 定义 Token 接口**
```java
public interface RefreshToken extends Token {
    String getRefreshTokenId();
    ZonedDateTime getRefreshExpirationTime();
}
```

**步骤 2: 实现 Token**
```java
public class DefaultRefreshToken extends AbstractToken implements RefreshToken {
    private static final String PREFIX = "RT";
    private String refreshTokenId;
    private ZonedDateTime refreshExpirationTime;

    @Override
    public String getId() {
        return PREFIX + super.getId();
    }

    // 实现其他方法...
}
```

**步骤 3: 实现 TokenFactory**
```java
@Component
public class RefreshTokenFactory implements TokenFactory {

    @Override
    public Class<? extends Token> getTokenType() {
        return RefreshToken.class;
    }

    @Override
    public Token createToken(Authentication authentication) {
        DefaultRefreshToken token = new DefaultRefreshToken();
        token.setAuthentication(authentication);
        token.setExpirationPolicy(buildExpirationPolicy());
        token.setRefreshTokenId(generateRefreshId());
        return token;
    }

    // 实现其他方法...
}
```

**步骤 4: 注册到 Spring**
```java
@Configuration
public class CustomTokenConfig {

    @Bean
    public TokenFactory refreshTokenFactory() {
        return new RefreshTokenFactory();
    }
}
```

### 8.2 自定义 ExpirationPolicy

```java
public class SlidingWindowExpirationPolicy extends AbstractTokenExpirationPolicy {

    private final Duration windowSize;
    private final int maxUses;

    @Override
    public boolean isExpired(Token token) {
        // 滑动窗口策略: 在时间窗口内使用次数不超过限制
        ZonedDateTime windowStart = ZonedDateTime.now().minus(windowSize);

        if (token.getLastTimeUsed().isBefore(windowStart)) {
            return true;  // 超出时间窗口
        }

        if (token.getCountOfUses() > maxUses) {
            return true;  // 超出使用次数
        }

        return false;
    }

    @Override
    public Long getTimeToLive() {
        return windowSize.toSeconds();
    }

    @Override
    public Long getTimeToIdle() {
        return windowSize.toSeconds();
    }
}
```

**使用示例**:
```java
@Bean
public ExpirationPolicyBuilder customExpirationPolicyBuilder() {
    return new ExpirationPolicyBuilder() {
        @Override
        public ExpirationPolicy buildTokenExpirationPolicy() {
            return new SlidingWindowExpirationPolicy(
                Duration.ofHours(1),  // 1小时窗口
                100                    // 最多100次使用
            );
        }
    };
}
```

### 8.3 自定义 TokenRegistry

```java
public class DatabaseTokenRegistry extends AbstractTokenRegistry {

    private final TokenRepository tokenRepository;  // JPA Repository

    @Override
    protected void addTokenInternal(Token token) throws Exception {
        TokenEntity entity = convertToEntity(token);
        tokenRepository.save(entity);
    }

    @Override
    public Token getToken(String tokenId, Predicate<Token> predicate) {
        TokenEntity entity = tokenRepository.findById(tokenId).orElse(null);
        if (entity == null) {
            return null;
        }

        Token token = convertToToken(entity);
        return predicate.test(token) ? token : null;
    }

    @Override
    public Token deleteTokenInternal(String tokenId) {
        Token token = getToken(tokenId);
        if (token != null) {
            tokenRepository.deleteById(tokenId);
        }
        return token;
    }

    @Override
    public long deleteAll() {
        long count = tokenRepository.count();
        tokenRepository.deleteAll();
        return count;
    }

    @Override
    public boolean deleteToken(String tokenId, Predicate<Token> predicate) {
        Token token = getToken(tokenId);
        if (token != null && predicate.test(token)) {
            tokenRepository.deleteById(tokenId);
            return true;
        }
        return false;
    }

    @Override
    public Collection<Token> getTokens() {
        return tokenRepository.findAll().stream()
            .map(this::convertToToken)
            .collect(Collectors.toList());
    }

    @Override
    public Stream<String> getTokenIds() {
        return tokenRepository.findAllIds().stream();
    }

    @Override
    public long sessionCount() {
        return tokenRepository.count();
    }

    @Override
    public Stream<Token> stream() {
        return tokenRepository.findAll().stream()
            .map(this::convertToToken);
    }
}
```

**注册到 Spring**:
```java
@Configuration
public class CustomTokenRegistryConfig {

    @Bean
    @ConditionalOnProperty(name = "imaping.token.registry.database.enabled", havingValue = "true")
    public TokenRegistry databaseTokenRegistry(TokenRepository tokenRepository) {
        return new DatabaseTokenRegistry(tokenRepository);
    }
}
```

### 8.4 自定义 Security 配置

```java
@Configuration
@EnableWebSecurity
public class CustomSecurityConfig extends TokenSecurityConfig {

    @Override
    protected String[] getPermitAntMatchers() {
        return new String[]{
            "/public/**",
            "/login",
            "/register",
            "/health",
            "/actuator/health"
        };
    }

    @Override
    protected String[] getAuthenticatedAntMatchers() {
        return new String[]{
            "/api/**",
            "/admin/**",
            "/user/**"
        };
    }

    @Bean
    @Override
    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
        SecurityFilterChain chain = super.apiFilterChain(http);

        // 添加自定义配置
        http
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .headers(headers -> headers
                .frameOptions(frame -> frame.sameOrigin())
            );

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("https://example.com"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

### 8.5 自定义 Token 清理策略

```java
@Component
public class CustomTokenRegistryCleaner implements TokenRegistryCleaner {

    private final TokenRegistry tokenRegistry;
    private final int batchSize = 100;

    @Override
    @Scheduled(cron = "0 */10 * * * *")  // 每10分钟执行一次
    public void clean() {
        long totalCleaned = 0;

        try (Stream<Token> tokenStream = tokenRegistry.stream()) {
            List<Token> batch = new ArrayList<>();

            tokenStream
                .filter(Token::isExpired)
                .forEach(token -> {
                    batch.add(token);

                    if (batch.size() >= batchSize) {
                        totalCleaned += cleanBatch(batch);
                        batch.clear();
                    }
                });

            // 清理剩余的 Token
            if (!batch.isEmpty()) {
                totalCleaned += cleanBatch(batch);
            }
        }

        log.info("Token cleanup completed. Cleaned {} tokens.", totalCleaned);
    }

    private long cleanBatch(List<Token> tokens) {
        return tokens.stream()
            .map(Token::getId)
            .filter(id -> tokenRegistry.deleteToken(id) != null)
            .count();
    }
}
```

---
